# 재귀(Recursion)

### 재귀(Recursion) 란?

---

<br>

- 어떠한 문제를 해결할 때, 구조는 동일하지만 더 작은 경우를 해결함으로써 그 문제를 해결하는 방법
- 어떤 함수가 스스로를 호출하는 것

<br>

예제

1.  원래의 문제에서 출발하여 더 작은 경우를 생각한다.

        arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]);

2.  계속해서 문제가 더는 작아지지 않을 때까지 더 작은 경우를 생각한다.

        arrSum([3, 6, 2]) = 3 + arrSum([6, 2]);
        arrSum([6, 2]) = 6 + arrSum([2]);
        arrSum([2]) = 2 + arrSum([]);

3.  이렇게 문제 풀기를 미루다가, 문제가 간단해져서 바로 풀 수 있게 되는 순간에 미뤄왔던 문제들을 차근차근 해결한다.

        arrSum([]) = 0; // < — 문제가 더는 작아지지 않는 순간
        // 가장 작은 경우의 해결책을 적용한다.
        arrSum([2]) = 2 + arrSum([]) = 2;
        arrSum([6, 2]) = 6 + arrSum([2]) = 6 + 2 = 8;
        arrSum([3, 6, 2]) = 3 + arrSum([6, 2]) = 3+ 8 = 11;
        arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]) = 10 + 11 = 21;

<br>
<br>

### 재귀의 3가지 중요한 특성

---

- 종료 조건

  - `if(나쁜 값이 들어왔다면) { 정지! };` 와 같이 이해하기
  - 종료조건은 재귀의 안전장치(좋지 않은 입력 값이 들어왔을 때 재귀가 계속하여 동작하는것을 막아줌)

- 기반 조건(Base case)

  - `if(이런 일이 일어난다면) { 성공! }` 과 같이 이해하기
  - 이 조건 역시 재귀 함수를 멈춘다는 점을 감안하면, 종료조건과 비슷할 수 있지만 기반조건은 재귀 함수의 **목적**

- 재귀

  - 함수가 자기 자신을 호출하는 것

<br>

### 재귀를 사용하는 이유

---

<br>

- 주어진 문제가(구조는 비슷하고) 더 작은 문제로 나뉘어 질 수 있는 경우
- 중첩된 루프가 많거나 중첩의 정도(number of loops)를 미리 알 수 없는 경우

<br>

### 재귀적 사고 연습하기

---

<br>

1. 재귀 함수의 입력값과 출력값 정의하기

   - 문제를 가장 추상적으로 또는 가장 단순하게 정리

2. 문제를 쪼개고 경우의 수를 나누기

   - 어떤 기준을 정하고 그 기준에 따라 문제를 더 큰 경우와 작은 경우로 구분할 수 있는지 검토(대부분은 순서와 크기)

   - 일반적으로 입력값이 이 기준을 정하는 대상이 된다.

3. 단순한 문제 해결하기

   - 문제를 여러 경우로 구분한 다음에는 쉬운 문제부터 해결한다. 이를 재귀의 기초(base case)라고 부른다.

4. 복잡한 문제 해결하기

   - 남아있는 복잡한 경우를 해결

5. 코드 구현하기

<br>

### factorial로 알아보는 재귀

---

    function fac(n) {
      if(n === 1) {
        return 1;
      }
      return n * fac(n-1)
    }

- 주의사항!
  - return 으로 불러져오는 fac(n-1)함수는 함수 그 자체를 불러오는 것이 아니라 원본의 복사본을 불러온다.

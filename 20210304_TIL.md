# 자료구조 - Graph / Tree

## Graph

### Graph란?

<br>

노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조입니다. 서로 다른 점들이 직접적인 관계를 가지고 있다면 바로 이어주는 선이 존재하고, 간접적인 관계를 가지고 있다면 다른 여러 점을 거쳐서 이어지는 선이 존재할 수 있습니다. 여기에서 이야기하는 점은 그래프에서는 정점(vertex)이라고 표현하고, 선은 간선(edge)이라고 표현합니다.

<br>

### 알아둬야 할 그래프 용어들

<br>

- 무향그래프(undirected graph)
  - 무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있습니다.
  - 정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현한다.
- 진입차수(in-degree) : 방향 그래프에서 외부에서 오는 간선의 수(내차수 라고도 부름)
- 진출차수(out-degree) : 방향 그래프에서 외부로 향하는 간선의 수(외차수 라고도 부름)
- 인접(adjacency) : 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점입니다.
- 자기 루프(self loop) : 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 **자기 루프를 가졌다** 라고 표현합니다. 다른 정점을 거치지 않는다는 것이 특징입니다.
- 사이클(cycle) : 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 **사이클이 있다**고 표현합니다.

<br>

### 인접 행렬

<br>

인접 행렬은 NxN 불린 행렬(Boolean Matrix)로써 matrix[i][j]가 true라면 i -> j로의 간선이 있다는 뜻입니다. 정점(노드)의 개수가 N인 그래프를 인접 행렬로 표현할 수 있습니다. 특히나 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭 행렬이 됩니다.

<br>

- 언제 인접 행렬을 사용하면 좋을까?

<br>

1.  한 개의 큰 표와 같은 모습을 한 인접 행렬은 두 정점 사이에 관계기 았는지, 없는지 확인하기에 용이합니다. 예를 들어, A에서 B로 진출하는 간선이 있는지 파악하기 위해선 0번째 줄의 1번째 열에 어떤 값이 저장되어있는지 바로 확인할 수 있습니다.
2.  가장 빠른 경로(shortest path)를 찾고자 할 때 주로 사용됩니다.

<br>

### 인접 리스트

<br>

인접 리스트로 그래프를 표현하는 것이 가장 일반적인 방법입니다. 모든 정점(혹은 노드)을 인접 리스트에 저장합니다. 즉, 각각의 정점에 인접한 정점들을 리스트로 표시한 것 입니다. 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 리스트에 쉽게 접근할 수 있습니다. 또한, 무방향 그래프에서 (a,b) 간선은 두번 저장됩니다. 그리고 보통은 인접 리스트의 순서는 중요하지 않습니다. 우선순위가 팔요하다면 큐나 힙과 같은 다른 자료구조를 사용하는 것이 더 합리적입니다.

<br>

- 언제 인접 리스트를 사용하면 좋을까?

<br>

1. 인접행렬은 연결 가능한 모든 경우의 수를 저장합니다. 그렇기 때문에 메모리를 많이 차지하게 되고, 메모리를 효율적으로 사용하고 싶다면 인접 행렬 대신 인접 리스트를 사용합니다.

<br>
<br>

## Tree

### Tree란?

<br>

데이터가 바로 아래에 있는 하나 이상의 데이터에 단방향으로 연결되는 계층적 자료구조입니다. 데이터를 순차적으로 나열시킨 형태인 선형 구조가 아닌, 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조로 되어있고, 계층적으로 표현이 되며 아래로만 뻗기 때문에 사이클이 없습니다.
트리 구조는 루트(Root)라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)으로 연결합니다. 이 데이터들은 노드(Node)라고 하며, 상위 노드와 하위 노드가 연결이 되면 부모/자식 관계를 가지게 됩니다. 자식이 없는 노드는 나무의 잎과 같다고 하여 리프 노드라고 부릅니다.
이 자료구조는 특이하게도 높이와 깊이를 잴 수 있습니다. 루트에서 자신에게 걸리는 거리를 레벨(Level)이라고 부르며, 루트를 Level 1로 설정합니다. 노드와 노드의 간격(거리)를 레벨(Level)이라고 부르며, 첫 번째 노드인 루트를 Level 1로 설정합니다. **루트부터 가장 안쪽에 있는 노드까지의 레벨을 트리의 높이(Height)**라고 하고, 반대로 **특정 노드부터 시작하여 루트까지의 레벨을 노드의 깊이(depth)**라고 표현합니다. **같은 레벨에 나란히 있는 노드들은 형제 노드(sibling Node)**로 표현하고 있습니다.

<br>

- 트리의 실사용 예제

<br>

컴퓨터 디렉토리의 구조, 월드컵 토너먼트 대진표, 가계도, 조직도 등
<br>

### (Binary Search Tree)BST

<br>

트리는 편리한 구조를 전시하는 것 외에 효율적인 탐색을 위해 사용하기도 합니다. 여러 특징을 가진 트리 중 대표적인 트리들에 대해 알아봅시다.

- 완전 이진 트리(Binary Search Tree) : 마지막 레벨을 제외한 모든 노드가 가득 차 있어야하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 합니다.

- 정 이진 트리(Binary Tree) : 각 노드가 0개 혹은 2개의 자식노드를 갖습니다.

- 포화 이진 트리(Perfect Binary Tree) : 정 이진 트리이면서 완전 이진 트리인 경우입니다. 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있는 트리입니다.

<br>

모든 왼쪽 자식들은 루트나 부모보다 작은 값이고, 모든 오른쪽 자식들은 루트나 부모보다 큰 값인 특징을 가지고 있는 이진트리를 이진 탐색 트리라고 정의합니다.
